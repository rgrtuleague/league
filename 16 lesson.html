<!--

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lesson 16</title>
    <style>
        body {
            background-color: #363;
            color: #fff;
        }
    </style>
</head>
<body>
<h1>Title</h1>

<p>Some patterns to reduce coupling are object factories or dependency injection.
    These patterns can benefit of the construct() function.
    This function receives a constructor function and possibly some arguments
    and it returns a new object constructed with the function and the passed arguments.</p>

<ul>
    <li>Item1</li>
    <li>Item2</li>
    <li>Item3</li>
    <li>Item4</li>
    <li>Item5</li>
</ul>

<script>
    var bodyStyle = document.body.style;

    bodyStyle.backgroundColor = '#2ee';
    bodyStyle.color = '#433';

    var li = document.body.children[2].children[4];

    li.style.backgroundColor = '#333';
    li.style.color = '#fff';

</script>

</body>
</html>
-->

<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="16%20lesson.css" type="text/css">   <!-- Подключаем CSS-файл-->
</head>

<body>
<div class="article">Пользователи:</div>
<ul class="spis">
    <li id="Masha">Маша</li>
    <li id="Vova">Вовочка</li>
</ul>

<table id="tabl" border="1">
    <caption>Выписка лицевого счета</caption>
    <tr>
        <th>Month</th>
        <th>Balance</th>
    </tr>
    <tr>
        <td id="mon1"><a href="ab1" name="j">Junuare</a></td>
        <td id="price1">500 rub</td>
    </tr>
    <tr>
        <td id="mon2"><a href="ab2" name="f">February</a></td>
        <td id="price2">800 rub</td>
    </tr>
    <tr>
        <td id="mon3"><a href="ab3" name="m">March</a></td>
        <td id="price3">300 rub</td>
    </tr>
    <tr>
        <td id="mon4"><a href="ab4" name="ap">April</a></td>
        <td id="price4">700 rub</td>
    </tr>
</table>

<img src="Горы.jpg" alt="Mountains"
        width="300" height="200"/>

<ul>
    <li>Этот</li>
    <li>тест</li>
</ul>
<ul>
    <li>полностью</li>
    <li>пройден</li>
</ul>
<ul>
    <li class="chapter">Глава I
        <ul>
            <li class="subchapter">Глава <span class="num">1.1</span></li>
            <li class="subchapter">Глава <span class="num">1.2</span></li>
        </ul>
    </li>
</ul>

<!-- ТИП nodeType -->
<div>Читатели</div>
<ul>
    <li>Вася</li>
    <li>Петя</li>
</ul>
<!-- Комментарий -->


<div class="textCont1">1</div>
<div class="textCont2">2</div>
<!-- комментарий -->

<script>
    //Поиск по id
  /*var elemMon = document.getElementById('mon3');
  elemMon.style.background = 'green';

  var elemPrice = document.getElementById('price2');
  elemPrice.style.background = 'yellow';*/
    //-----------------------------------------------------------------
  // Поиск по TagName
   /* var elemTable = document.getElementById('tabl');
    elemTable.style.backgroundColor = 'white';
    elemTable.style.color = 'grey';
console.log(elemTable);
    var cap = elemTable.getElementsByTagName('*');

    for (var i = 0; i < cap.length; i++) {
        cap[i].style.color = 'brown';
    }
    console.log(cap);
    */
//------------------------------------------------------------------------------
   // Поиск по отрибуту name
    /*var elems = document.getElementsByName('ap');
    elems[0].style.color = 'green';*/
//----------------------------------------------------------------------------
    // Поиск по ClassName
    /*var elems = document.getElementsByClassName('spis');
    elems[0].style.backgroundColor = '#677';*/
//--------------------------------------------------------------------------
    // querySelectorAll  (поиск по CSS-селектору)
   /* var elements = document.querySelectorAll('ul > li:last-child');

     for (var i = 0; i < elements.length; i++) {
     console.log( elements[i].innerHTML ); // "Вовочка", "тест", "пройден"
     }*/
//--------------------------------------------------------------------------
    // mathes - ничего не ищет, а только проверяет
   /* var elems = document.body.children;
   for (var i=0; i<elems.length;i++) {
       if (elems[i].matches('ul[class="spis"]')) {
           alert('ul class = spis');
       }
   }*/
//------------------------------------------------------------------------
    // closest
    /*Метод elem.closest(css) ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css.
        Сам элемент тоже включается в поиск.*/
    /*
var numberSpan = document.querySelector('.num');
console.log(numberSpan);

    // ближайший элемент сверху подходящий под селектор li
    console.log(numberSpan.closest('li').className);

    // ближайший элемент сверху подходящий под селектор .chapter
    console.log(numberSpan.closest('.chapter').tagName);

    // ближайший элемент сверху, подходящий под селектор span
    // это сам numberSpan, так как поиск включает в себя сам элемент
    console.log(numberSpan.closest('span'));
    */
    //--------------------------------------------------------------------------
// тип nodeType
   /* interface Node {
        // Всевозможные значения nodeType
        const unsigned short ELEMENT_NODE = 1;
        const unsigned short ATTRIBUTE_NODE = 2;
        const unsigned short TEXT_NODE = 3;
        const unsigned short CDATA_SECTION_NODE = 4;
        const unsigned short ENTITY_REFERENCE_NODE = 5;
        const unsigned short ENTITY_NODE = 6;
        const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
        const unsigned short COMMENT_NODE = 8;
        const unsigned short DOCUMENT_NODE = 9;
        const unsigned short DOCUMENT_TYPE_NODE = 10;
        const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
        const unsigned short NOTATION_NODE = 12;
    ...
    }*/
    /*var childNodes = document.body.childNodes;
    for(var i=0;i<childNodes.length;i++) {
        if (childNodes[i].nodeType != 1) // ELEMENT_NODE = 1
            continue;
        alert(childNodes[i]);
    }*/
    //------------------------------------------------------------------------------
// тег: nodeName и TagName
    // При помощи tagName мы можем работать только с элементами, а nodeName может что-то сказать и о других типах узлов.
    //console.log(document.body.children[1].nodeName);
    //---------------------------------------------------------------------

    // innerHTML - содержимое элемента
    // можно и читать, и писать
    /*document.getElementById('Masha').innerHTML = 'Катя';
    document.querySelector('ul li').innerHTML = 'Vika';*/
    //------------------------------------------------------------------------------

    // outerHTML - элемент HTML целиком
    /*var elem = document.body.children[0];
    console.log(elem.outerHTML); */// <div class="article">Пользователи:</div>
    // Изменить outerHTML элемента невозможно
    //-------------------------------------------------------------------------

    // data - содержимое текстового узла
     // Если свойство innerHTML есть только у узлов-элементов, то содержимое других узлов,
     // например, текстовых или комментариев, доступно на чтение и запись через свойство data.
    /*for (var i=13;i<document.body.childNodes.length;i++) {
        console.log(document.body.childNodes[i].data); // Тип nodeType, ... Комментарий ..
    }*/
//---------------------------------------------------------------------------------

    // textContent - содержит только текст внутри элемента, за вычетом всех <тегов>
   /* var elem = document.body.children[4];
    console.log(elem.textContent);*/  // Этот
                                    // тест
    /*Как видно из примера выше, возвращается в точности весь текст, включая переводы строк и пробелы, но без тегов.
        Иными словами, elem.textContent возвращает конкатенацию всех текстовых узлов внутри elem.*/

   /* Не сказать, чтобы эта информация была часто востребована.
        Гораздо полезнее возможность записать текст в элемент, причём именно как текст!
        В этом примере имя посетителя попадёт в первый div как innerHTML, а во второй – как текст:*/
  /* var name = prompt("Enter name", "<b>Vinni-Pooh</b>");
var elem1 = document.getElementsByClassName('textCont1');
    elem1[0].innerHTML = name;  // Vinni-pooh
var elem2 = document.getElementsByClassName("textCont2");
    elem2[0].textContent = name; // <b>Vinni-Pooh</b>*/
  //----------------------------------------------------------------------------

    // Свойство hidden
    /*Как правило, видим или невидим узел, определяется через CSS, свойствами display или visibility.
        В стандарте HTML5 предусмотрен специальный атрибут и свойство для этого: hidden.*/
    // в body:   <div hidden> text</div>
    // или в скрипте:
    var lastChild = document.getElementsByClassName('textCont1');
    console.log(lastChild[0]);
    lastChild[0].hidden = true;
</script>

</body>

</html>



























